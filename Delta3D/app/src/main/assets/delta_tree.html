<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<title>Delta Tree - Growth Simulation Model</title>
	<style>
		* { margin: 0; padding: 0; box-sizing: border-box; }
		body {
			margin: 0;
			overflow: hidden;
			background-color: #0F2027;
			user-select: none;
			touch-action: none;
			font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
		}
		#canvas-container {
			width: 100vw;
			height: 100vh;
			position: absolute;
			top: 0;
			left: 0;
		}
		#loading {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: #0F2027;
			z-index: 100;
			display: flex;
			justify-content: center;
			align-items: center;
			flex-direction: column;
			transition: opacity 1s;
		}
		.loader {
			width: 10px;
			height: 10px;
			background: #7DD3E8;
			border-radius: 50%;
			animation: pulse 1.5s ease-in-out infinite;
		}
		.loading-text {
			color: rgba(255,255,255,0.6);
			font-size: 14px;
			margin-top: 20px;
		}
		@keyframes pulse {
			0%, 100% { opacity: 0.3; transform: scale(1); }
			50% { opacity: 1; transform: scale(1.5); }
		}

		/* Control buttons */
		.control-buttons {
			position: fixed;
			bottom: 30px;
			left: 50%;
			transform: translateX(-50%);
			display: flex;
			z-index: 50;
			opacity: 0;
			transition: opacity 0.5s;
		}
		.control-buttons.show {
			opacity: 1;
			pointer-events: auto;
		}
		.ctrl-btn {
			width: 60px;
			height: 60px;
			border-radius: 50%;
			border: 1px solid rgba(255, 255, 255, 0.3);
			background: rgba(255, 255, 255, 0.15);
			backdrop-filter: blur(10px);
			-webkit-backdrop-filter: blur(10px);
			color: rgba(255, 255, 255, 0.9);
			font-size: 24px;
			display: flex;
			align-items: center;
			justify-content: center;
			cursor: pointer;
			transition: all 0.2s;
			outline: none;
			-webkit-tap-highlight-color: transparent;
			box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
			margin: 0 18px;
		}

		.ctrl-btn svg {
			width: 28px;
			height: 28px;
			fill: none;
			stroke: rgba(255, 255, 255, 0.85);
			stroke-width: 2;
			stroke-linecap: round;
			stroke-linejoin: round;
			filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.3));
		}

		.ctrl-btn:focus {
			outline: none;
		}

		.ctrl-btn:active {
			background: rgba(255, 255, 255, 0.25);
			transform: scale(0.95);
			border-color: rgba(255, 255, 255, 0.5);
		}

		.ctrl-btn:active svg {
			stroke: rgba(255, 255, 255, 1);
		}

		.ctrl-btn.active {
			background: rgba(255, 255, 255, 0.3);
			border-color: rgba(255, 255, 255, 0.6);
			box-shadow: 0 4px 20px rgba(255, 255, 255, 0.15);
		}

		.ctrl-btn.active svg {
			stroke: rgba(255, 255, 255, 1);
			filter: drop-shadow(0 0 6px rgba(255, 255, 255, 0.5));
		}

		/* Hint text */
		.hint {
			position: fixed;
			top: 80px;
			left: 50%;
			transform: translateX(-50%);
			color: rgba(255,255,255,0.7);
			font-size: 14px;
			text-align: center;
			z-index: 50;
			padding: 10px 20px;
			background: rgba(0,0,0,0.4);
			border-radius: 20px;
			opacity: 0;
			transition: opacity 0.5s;
		}
		.hint.show {
			opacity: 1;
			animation: fadeOut 4s ease-in-out 2s forwards;
		}
		@keyframes fadeOut {
			from { opacity: 1; }
			to { opacity: 0; }
		}

		/* Welcome overlay */
		#welcome-overlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.5);
			z-index: 200;
			display: flex;
			align-items: center;
			justify-content: center;
			opacity: 0;
			transition: opacity 0.4s;
			pointer-events: none;
		}
		#welcome-overlay.show {
			opacity: 1;
			pointer-events: auto;
		}
		.welcome-card {
			background: rgba(25, 45, 55, 0.85);
			border: 1px solid rgba(255, 255, 255, 0.15);
			border-radius: 24px;
			padding: 32px 28px;
			text-align: center;
			max-width: 320px;
			width: 85%;
			transform: scale(0.9);
			transition: transform 0.3s;
			backdrop-filter: blur(10px);
			-webkit-backdrop-filter: blur(10px);
			box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
		}
		#welcome-overlay.show .welcome-card {
			transform: scale(1);
		}
		.welcome-card h2 {
			color: rgba(255, 255, 255, 0.95);
			font-size: 22px;
			margin-bottom: 16px;
			font-weight: 500;
		}
		.welcome-card p {
			color: rgba(255, 255, 255, 0.7);
			font-size: 15px;
			line-height: 1.7;
			margin-bottom: 24px;
		}
		.welcome-card .start-btn {
			background: rgba(255, 255, 255, 0.95);
			border: none;
			color: #1a3040;
			padding: 16px 40px;
			border-radius: 30px;
			font-size: 17px;
			font-weight: 600;
			cursor: pointer;
			width: 100%;
			outline: none;
			-webkit-tap-highlight-color: transparent;
			transition: all 0.2s;
			box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
		}
		.welcome-card .start-btn:focus {
			outline: none;
		}
		.welcome-card .start-btn:active {
			background: rgba(255, 255, 255, 0.85);
			transform: scale(0.98);
		}
		.feature-list {
			text-align: left;
			margin: 20px 0;
			padding: 0 10px;
		}
		.feature-icon {
			font-size: 18px;
		}
		.feature-item {
			color: rgba(255, 255, 255, 0.7);
			font-size: 14px;
			margin: 12px 0;
			display: flex;
			align-items: center;
		}
		.feature-text {
			flex: 1;
		}
		.feature-icon {
			width: 36px;
			height: 36px;
			min-width: 36px;
			margin-right: 16px;
			border-radius: 50%;
			border: 1px solid rgba(255, 255, 255, 0.25);
			background: rgba(255, 255, 255, 0.1);
			backdrop-filter: blur(8px);
			-webkit-backdrop-filter: blur(8px);
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 16px;
			box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
		}
		.feature-icon svg {
			width: 18px;
			height: 18px;
			fill: none;
			stroke: rgba(255, 255, 255, 0.85);
			stroke-width: 2;
			stroke-linecap: round;
			stroke-linejoin: round;
		}
	</style>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
</head>
<body>
<div id="loading">
	<div class="loader"></div>
	<div class="loading-text">Initializing model...</div>
</div>

<div id="canvas-container"></div>

<!-- Welcome overlay -->
<div id="welcome-overlay">
	<div class="welcome-card">
		<h2>Delta Tree</h2>
		<p style="font-size: 13px; color: rgba(255,255,255,0.65); margin-bottom: 12px;">
			A simplified computational model simulating organic growth patterns
		</p>
		<p>Experience procedural generation<br/>through interactive visualization</p>
		<div class="feature-list">
			<div class="feature-item">
				<span class="feature-icon">
					<svg viewBox="0 0 24 24">
						<path d="M12 2v6m0 0l3-3m-3 3L9 5"/>
						<circle cx="12" cy="14" r="6"/>
					</svg>
				</span>
				<span class="feature-text">Rotate view with touch gestures</span>
			</div>
			<div class="feature-item">
				<span class="feature-icon">
					<svg viewBox="0 0 24 24">
						<path d="M12 3v18M3 12h18"/>
						<circle cx="12" cy="12" r="3"/>
						<circle cx="12" cy="12" r="8"/>
					</svg>
				</span>
				<span class="feature-text">Toggle point cloud dispersion</span>
			</div>
			<div class="feature-item">
				<span class="feature-icon">
					<svg viewBox="0 0 24 24">
						<path d="M12 2L2 7l10 5 10-5-10-5z"/>
						<path d="M2 17l10 5 10-5"/>
						<path d="M2 12l10 5 10-5"/>
					</svg>
				</span>
				<span class="feature-text">Switch rendering modes</span>
			</div>
		</div>
		<button class="start-btn" onclick="startExperience()">Start Experience</button>
	</div>
</div>

<!-- Hint -->
<div class="hint" id="hint">Swipe to rotate Â· Tap buttons for effects</div>

<!-- Control buttons -->
<div class="control-buttons" id="controls">
    <button class="ctrl-btn" id="btn-scatter" onclick="toggleScatter()">
        <svg viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="2"/>
            <circle cx="6" cy="6" r="1.5"/>
            <circle cx="18" cy="6" r="1.5"/>
            <circle cx="6" cy="18" r="1.5"/>
            <circle cx="18" cy="18" r="1.5"/>
            <path d="M12 10V6M12 14v4M10 12H6M14 12h4"/>
        </svg>
    </button>
    <button class="ctrl-btn" id="btn-jitter" onclick="toggleJitter()">
        <svg viewBox="0 0 24 24">
            <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
        </svg>
    </button>
    <button class="ctrl-btn" id="btn-season" onclick="toggleSeason()">
        <svg viewBox="0 0 24 24">
            <path d="M12 22c-4-4-8-7-8-12a8 8 0 1 1 16 0c0 5-4 8-8 12z"/>
            <path d="M12 22V12"/>
            <path d="M9 15l3-3 3 3"/>
        </svg>
    </button>
</div>

<script>
	// ========== State ==========
	const state = {
		growth: 0.0, targetGrowth: 1.1,
		scatter: 0.0, targetScatter: 0.0,
		jitter: 0.0, targetJitter: 0.0,
		season: 0.0, targetSeason: 0.0,
		autoRotateAngle: 0.0,
		cameraZ: 36, targetCameraZ: 36,
		baseCameraZ: 36, farCameraZ: 70
	};

	let scene, camera, renderer, composer, particleSystem, seedMesh;
	let touchStartX = 0, touchStartY = 0, manualRotation = 0, isAutoRotate = true;
	let lastTouchTime = 0;
	const particlesData = { positions: [], colors: [], sizes: [], extras: [] };

	const CONFIG = {
		colors: {
			trunk: new THREE.Color(0xE8F4F8),
			trunkHighlight: new THREE.Color(0x7DD3E8),
			leafSpring: new THREE.Color(0x7DD3E8),
			leafAutumn: new THREE.Color(0xFF3333),
			ground: new THREE.Color(0x8A9A9D),
			water: new THREE.Color(0x40A4D8)
		}
	};

	// ========== Control functions ==========
	function toggleScatter() {
		state.targetScatter = state.targetScatter > 0.5 ? 0 : 1;
		document.getElementById('btn-scatter').classList.toggle('active', state.targetScatter > 0.5);
	}

	function toggleJitter() {
		state.targetJitter = state.targetJitter > 0.5 ? 0 : 1;
		state.targetCameraZ = state.targetJitter > 0.5 ? state.farCameraZ : state.baseCameraZ;
		document.getElementById('btn-jitter').classList.toggle('active', state.targetJitter > 0.5);
	}

	function toggleSeason() {
		state.targetSeason = state.targetSeason > 0.5 ? 0 : 1;
		document.getElementById('btn-season').classList.toggle('active', state.targetSeason > 0.5);
	}

	function startExperience() {
		document.getElementById('welcome-overlay').classList.remove('show');
		setTimeout(() => {
			document.getElementById('hint').classList.add('show');
			document.getElementById('controls').classList.add('show');
		}, 300);
	}

	// ========== Initialization ==========
	function init() {
		console.log('Initializing Three.js');
		const container = document.getElementById('canvas-container');

		scene = new THREE.Scene();
		scene.background = new THREE.Color(0x0F2027);
		scene.fog = new THREE.FogExp2(0x0F2027, 0.012);

		camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 500);
		camera.position.set(0, 1, 60);
		camera.lookAt(0, 0, 0);

		renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
		container.appendChild(renderer.domElement);

		const renderScene = new THREE.RenderPass(scene, camera);
		const bloomPass = new THREE.UnrealBloomPass(
			new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85
		);
		bloomPass.threshold = 0.3;
		bloomPass.strength = 0.6;
		bloomPass.radius = 0.2;

		composer = new THREE.EffectComposer(renderer);
		composer.addPass(renderScene);
		composer.addPass(bloomPass);

		generateBalancedTree();
		createUnifiedParticleSystem();
		createSeed();
		setupTouchControls();

		window.addEventListener('resize', onWindowResize, false);

		// Hide loading, show welcome
		setTimeout(() => {
			const loading = document.getElementById('loading');
			loading.style.opacity = '0';
			setTimeout(() => {
				loading.style.display = 'none';
				document.getElementById('welcome-overlay').classList.add('show');
			}, 300);
		}, 800);

		animate();
		console.log('Three.js initialized');
	}

	function setupTouchControls() {
		const container = document.getElementById('canvas-container');

		container.addEventListener('touchstart', (e) => {
			touchStartX = e.touches[0].clientX;
			touchStartY = e.touches[0].clientY;
			isAutoRotate = false;
			lastTouchTime = Date.now();
		}, { passive: true });

		container.addEventListener('touchmove', (e) => {
			const deltaX = e.touches[0].clientX - touchStartX;
			manualRotation += deltaX * 0.008;
			touchStartX = e.touches[0].clientX;
		}, { passive: true });

		container.addEventListener('touchend', () => {
			setTimeout(() => {
				if (Date.now() - lastTouchTime > 1500) {
					isAutoRotate = true;
				}
			}, 2000);
		}, { passive: true });

		// Double tap to toggle effects
		let lastTap = 0;
		container.addEventListener('touchend', (e) => {
			const now = Date.now();
			if (now - lastTap < 300) {
				// Double tap: random effect toggle
				const effects = [toggleScatter, toggleJitter, toggleSeason];
				effects[Math.floor(Math.random() * effects.length)]();
			}
			lastTap = now;
		});
	}

	function generateBalancedTree() {
		const SCALE_X = 25, SCALE_H = 35, OFFSET_Y = -5;
		const mapX = (v) => (v - 0.5) * SCALE_X;
		const mapY = (v) => (0.58 - v) * SCALE_H + OFFSET_Y;
		const mapZ = (v) => v * SCALE_X;
		const trunkHeight = 0.38, trunkBaseY = 0.58, baseRadius = 0.9, splitT = 0.25, spreadAmount = 0.08;
		const groundY = mapY(trunkBaseY);

		// Trunk
		for (let layer = 0; layer < 5; layer++) {
			const layerRadius = baseRadius * (0.6 + layer * 0.1);
			for (let i = 0; i < 150; i++) {
				const t = i / 149.0;
				const kY = trunkBaseY - t * trunkHeight;
				const y = mapY(kY);
				const theta = Math.random() * Math.PI * 2;
				const r = layerRadius * (1.0 - t * 0.6);

				if (t < splitT) {
					const x = mapX(0.5) + Math.cos(theta) * r;
					const z = Math.sin(theta) * r;
					addParticle(x, y, z, CONFIG.colors.trunk, 1.8, 0, 0.0 + t * 0.2);
					addParticle(x, groundY - (y - groundY), z, CONFIG.colors.trunk, 1.8, 4, 0.0 + t * 0.2);
				} else {
					const dir = (i % 2 === 0) ? -1 : 1;
					const splitProgress = (t - splitT) / (1.0 - splitT);
					const splitOffset = Math.sin(splitProgress * Math.PI * 0.5) * spreadAmount;
					const x = mapX(0.5 + dir * splitOffset) + Math.cos(theta) * r * 0.6;
					const z = mapZ(dir * splitOffset * 0.3) + Math.sin(theta) * r * 0.6;
					addParticle(x, y, z, CONFIG.colors.trunk, 1.8, 0, 0.0 + t * 0.2);
					addParticle(x, groundY - (y - groundY), z, CONFIG.colors.trunk, 1.8, 4, 0.0 + t * 0.2);
				}
			}
		}

		// Branches
		const branchQueue = [], leafAttachPoints = [];
		const mainConfigs = [
			[-85, 0.35, 0.35], [85, 0.35, 0.35], [-75, 0.32, 0.38], [75, 0.32, 0.38],
			[-60, 0.30, 0.42], [60, 0.30, 0.42], [-50, 0.28, 0.45], [50, 0.28, 0.45],
			[-40, 0.26, 0.50], [40, 0.26, 0.50], [-30, 0.25, 0.55], [30, 0.25, 0.55],
			[-20, 0.24, 0.60], [20, 0.24, 0.60], [-15, 0.22, 0.65], [15, 0.22, 0.65]
		];

		mainConfigs.forEach((cfg, i) => {
			const startT = cfg[2], startY = mapY(trunkBaseY - startT * trunkHeight), angle = cfg[0];
			let spineX = 0, spineZ = 0;
			if (startT > splitT) {
				const splitProgress = (startT - splitT) / (1.0 - splitT);
				const splitOffset = Math.sin(splitProgress * Math.PI * 0.5) * spreadAmount;
				const dir = (angle < 0) ? -1 : 1;
				spineX += dir * splitOffset;
				spineZ += dir * splitOffset * 0.3;
			}
			let yaw = i * 2.4;
			if (Math.abs(angle) > 85) yaw = (angle < 0) ? Math.PI : 0;
			branchQueue.push({
				x: mapX(0.5 + spineX), y: startY, z: mapZ(spineZ),
				pitch: Math.abs(angle) * Math.PI / 180, yaw: yaw,
				length: cfg[1] * SCALE_H * 0.9, level: 1, birthDelay: i * 0.015
			});
		});

		while (branchQueue.length > 0) {
			const b = branchQueue.shift();
			let pCount = Math.max(30, Math.min(150, Math.floor(b.length * 6.0)));
			for (let i = 0; i < pCount; i++) {
				const t = i / (pCount - 1);
				const finalPitch = b.pitch + Math.sin(t * Math.PI) * 0.1 * b.level * 0.3 - (t * t * 0.4);
				const vH = Math.sin(finalPitch), vV = Math.cos(finalPitch);
				const curLen = t * b.length;
				const x = b.x + vH * Math.cos(b.yaw) * curLen;
				const y = b.y + vV * curLen;
				const z = b.z + vH * Math.sin(b.yaw) * curLen;
				const threshold = 0.2 + b.birthDelay + t * 0.2;
				addParticle(x, y, z, CONFIG.colors.trunkHighlight, 1.2, 0, threshold);
				addParticle(x, groundY - (y - groundY), z, CONFIG.colors.trunkHighlight, 1.2, 4, threshold);
				if (i === pCount - 1) leafAttachPoints.push({ x, y, z, level: b.level, threshold });
				else if (b.level === 1 && i > pCount * 0.4 && i % 8 === 0) leafAttachPoints.push({ x, y, z, level: b.level + 1, threshold });
			}
			if (b.level < 4) {
				const numSub = b.level === 1 ? 3 : (b.level === 2 ? 2 : 1);
				for (let j = 0; j < numSub; j++) {
					const t = 0.3 + Math.random() * 0.6;
					const curLen = t * b.length;
					const finalPitch = b.pitch - (t * t * 0.4);
					const vH = Math.sin(finalPitch), vV = Math.cos(finalPitch);
					branchQueue.push({
						x: b.x + vH * Math.cos(b.yaw) * curLen, y: b.y + vV * curLen, z: b.z + vH * Math.sin(b.yaw) * curLen,
						pitch: b.pitch + (Math.random() - 0.5) * 0.4, yaw: b.yaw + (Math.random() - 0.5) * 1.5,
						length: b.length * (0.6 + Math.random() * 0.2), level: b.level + 1, birthDelay: b.birthDelay + 0.05 + j * 0.02
					});
				}
			}
		}

		// Foliage
		leafAttachPoints.forEach(pt => {
			const leafCount = pt.level === 1 ? 70 : (pt.level === 2 ? 35 : 12);
			const clusterRadius = pt.level === 1 ? 3.0 : (pt.level === 2 ? 1.8 : 0.9);
			for (let i = 0; i < leafCount; i++) {
				const theta = 2 * Math.PI * Math.random();
				const phi = Math.acos(2 * Math.random() - 1);
				const r = Math.cbrt(Math.random()) * clusterRadius;
				const x = pt.x + r * Math.sin(phi) * Math.cos(theta);
				const y = pt.y + r * Math.sin(phi) * Math.sin(theta) * 0.5 + clusterRadius * 0.2;
				const z = pt.z + r * Math.cos(phi);
				const thresh = pt.threshold + Math.random() * 0.2;
				addParticle(x, y, z, CONFIG.colors.leafSpring, 2.0, 1, thresh);
				addParticle(x, groundY - (y - groundY), z, CONFIG.colors.leafSpring, 2.0, 5, thresh);
			}
		});

		// Ground and water surface
		for(let i = 0; i < 150; i++) {
			const angle = Math.random() * Math.PI * 2, dist = 0.01 + Math.random() * 0.12;
			addParticle(Math.cos(angle) * dist * SCALE_X, mapY(trunkBaseY + Math.random() * 0.04), Math.sin(angle) * dist * SCALE_X, CONFIG.colors.trunk, 1.2, 0, 0.1 + i / 150 * 0.2);
		}
		for(let i = 0; i < 2000; i++) {
			const r = Math.sqrt(Math.random()) * 50, theta = Math.random() * Math.PI * 2;
			const x = Math.cos(theta) * r, z = Math.sin(theta) * r;
			if (r > 2.0) addParticle(x, groundY + Math.sin(x * 0.3) * 0.2 + Math.cos(z * 0.2) * 0.2, z, CONFIG.colors.ground, 1.2, 2, 0.8 + Math.random() * 0.2);
		}
		for(let i = 0; i < 6000; i++) {
			const r = Math.sqrt(Math.random()) * 70, theta = Math.random() * Math.PI * 2;
			if (r > 1.2) addParticle(Math.cos(theta) * r, groundY, Math.sin(theta) * r, CONFIG.colors.water, 2.5, 3, 0.8 + Math.random() * 0.2);
		}
	}

	function addParticle(x, y, z, color, size, type, threshold) {
		particlesData.positions.push(x, y, z);
		particlesData.colors.push(color.r, color.g, color.b);
		particlesData.sizes.push(size);
		particlesData.extras.push(type, threshold, Math.random());
	}

	function createUnifiedParticleSystem() {
		const geometry = new THREE.BufferGeometry();
		geometry.setAttribute('position', new THREE.Float32BufferAttribute(particlesData.positions, 3));
		geometry.setAttribute('color', new THREE.Float32BufferAttribute(particlesData.colors, 3));
		geometry.setAttribute('size', new THREE.Float32BufferAttribute(particlesData.sizes, 1));
		geometry.setAttribute('extras', new THREE.Float32BufferAttribute(particlesData.extras, 3));

		const material = new THREE.ShaderMaterial({
			uniforms: {
				time: { value: 0 }, growth: { value: 0 }, season: { value: 0 }, scatter: { value: 0 }, jitter: { value: 0 },
				colSpring: { value: CONFIG.colors.leafSpring }, colAutumn: { value: CONFIG.colors.leafAutumn }
			},
			transparent: true, depthWrite: false, blending: THREE.NormalBlending,
			vertexShader: `
				uniform float time, growth, season, scatter, jitter;
				uniform vec3 colSpring, colAutumn;
				attribute vec3 color; attribute float size; attribute vec3 extras;
				varying vec3 vColor; varying float vAlpha;
				void main() {
					float type = extras.x, threshold = extras.y, rnd = extras.z;
					float visible = smoothstep(threshold, threshold + (type < 0.5 || type == 4.0 ? 0.1 : 0.15), growth);
					vAlpha = visible;
					vec3 pos = position;
					pos.x += sin(time * 1.0 + pos.y * 0.5 + rnd * 10.0) * 0.015;
					if (type > 2.5) {
						float dist = length(pos.xz);
						float w1 = sin(dist * 1.0 - time * 3.0), w2 = sin(pos.x * 0.5 + pos.z * 0.3 + time * 1.5);
						float waveHeight = (w1 + w2) * 0.12 + (jitter + scatter) * sin(dist * 10.0 - time * 20.0) * 0.05;
						pos.y += waveHeight;
						if (type > 2.5 && type < 3.5) vAlpha *= 0.5 + w1 * 0.2;
						else { vAlpha *= 0.3; pos.x += w1 * 0.05; pos.z += w2 * 0.05; }
					}
					if (scatter > 0.01) {
						vec3 center = vec3(0.0, 10.0, 0.0), dir = normalize(pos - center);
						if (length(pos - center) < 0.1) dir = vec3(0.0, 1.0, 0.0);
						vec3 scatterOffset = dir * (15.0 + sin(time * 8.0 + rnd * 50.0) * 2.0) * scatter;
						if (type == 4.0 || type == 5.0) scatterOffset.y *= -1.0;
						else scatterOffset.y += scatter * 15.0 * rnd;
						pos += scatterOffset; vAlpha *= (1.0 - scatter * 0.6);
					}
					if (jitter > 0.01) {
						float wave = sin(pos.y * 50.0 + time * 60.0);
						pos += vec3(wave, wave * 0.5, wave) * 0.15 * jitter;
						pos += vec3(sin(time * 60.0 + rnd * 100.0), cos(time * 60.0 + rnd * 80.0), sin(time * 60.0 + rnd * 60.0)) * 0.05 * jitter;
					}
					vec3 finalColor = color;
					if ((type > 0.5 && type < 1.5) || type == 5.0) finalColor = mix(mix(colSpring, colAutumn, season), vec3(1.0), rnd * 0.2);
					if (type == 4.0 || type == 5.0) finalColor *= 0.6;
					vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
					gl_PointSize = size * (60.0 / -mvPosition.z) * visible;
					gl_Position = projectionMatrix * mvPosition;
					vColor = finalColor;
				}
			`,
			fragmentShader: `
				varying vec3 vColor; varying float vAlpha;
				void main() {
					if (vAlpha < 0.01) discard;
					float d = length(gl_PointCoord - 0.5);
					if (d > 0.5) discard;
					gl_FragColor = vec4(vColor, vAlpha * (1.0 - smoothstep(0.4, 0.5, d)));
				}
			`
		});
		particleSystem = new THREE.Points(geometry, material);
		scene.add(particleSystem);
	}

	function createSeed() {
		seedMesh = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshBasicMaterial({ color: 0xFFFFFF }));
		seedMesh.position.set(0, -5, 0);
		scene.add(seedMesh);
	}

	function updateState(dt) {
		state.growth += (state.targetGrowth - state.growth) * 0.2 * dt;
		state.scatter += (state.targetScatter - state.scatter) * 4.0 * dt;
		state.jitter += (state.targetJitter - state.jitter) * 2.0 * dt;
		state.season += (state.targetSeason - state.season) * 2.0 * dt;
		state.cameraZ += (state.targetCameraZ - state.cameraZ) * 3.0 * dt;

		if (isAutoRotate) state.autoRotateAngle += dt * 0.1;
		else state.autoRotateAngle = manualRotation;

		if (particleSystem) {
			const u = particleSystem.material.uniforms;
			u.time.value += dt;
			u.growth.value = state.growth;
			u.scatter.value = state.scatter;
			u.jitter.value = state.jitter;
			u.season.value = state.season;
		}

		seedMesh.visible = state.growth < 0.05;
		if (seedMesh.visible) seedMesh.scale.setScalar(1.0 + Math.sin(Date.now() * 0.005) * 0.3);

		const r = state.cameraZ;
		const tx = r * Math.sin(state.autoRotateAngle);
		const tz = r * Math.cos(state.autoRotateAngle);
		camera.position.lerp(new THREE.Vector3(tx, 10, tz), 0.05);
		camera.lookAt(0, 0, 0);
	}

	const clock = new THREE.Clock();
	function animate() {
		requestAnimationFrame(animate);
		updateState(clock.getDelta());
		composer.render();
	}

	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize(window.innerWidth, window.innerHeight);
		composer.setSize(window.innerWidth, window.innerHeight);
	}

	// Initialize
	init();
</script>
</body>
</html>